//-------------ДВУМЕРНЫЕ МАССИВЫ
//string[,] table = new string[2, 3]; (2-строки, 3-столбцы) - текст,
// table - выдуманное название массива, [,] - значит массив двумерный
// Обязательны:
// ● тип данных,
// ● квадратные скобки с запятой внутри,
// ● именование массива или идентификатор массива,
// ● оператор присваивания,
// ● обязательное условие new,(!!!)
// ● тип данных,
// ● количество строк и столбцов в квадратных скобках.
// Имя массива.GetLength(0) возвращает количество строк в вашем массиве. 
//Имя массива.GetLength(1)— количество столбцов

// String.Empty
// table [0,0] table [0,1] table [0,2] table [0,4]
// table [1,0] table [1,1] table [1,2] table [1,4]
// --------Таблица со строками (WORK)---------------------
// string[,] table = new string[2,5]; //ВМЕСТО [2,5] можно указать [,] Получится массив без указания размеров, например если массив уже задан (картинкой ниже, например)
// table[1, 2] = "слово";
// for (int rows = 0; rows < 2; rows++)
// {
//  for (int columns = 0; columns < 5; columns++)
//  {
//  Console.WriteLine($"- {table[rows, columns]} +");
//  }
// }

//----------Таблица с числами (WORK)-----------
// int[,] matrix = new int[3, 4];
// for (int i = 0; i < 3; i++)
// {
//  for (int j = 0; j < 4; j++)
//  {
//  Console.Write($"{matrix[i, j]} ");
//  }
// Console.WriteLine();
// }
// Написание через функцию .GetLength (длина)----WORK (тоже что и сверху)
// int[,] matrix = new int[3, 4];
// for (int i = 0; i < matrix.GetLength(0); i++)
// {
//  for (int j = 0; j < matrix.GetLength(1); j++)
//  {
//  Console.Write($"{matrix[i, j]} ");
//  }
// Console.WriteLine();
// }

//-------Заполнение матрицы случайными числами (WORK)-------
// сначала вывод с нулямим, потом заполненный массив

// void PrintArray(int[,] matr) //matr  - это выдумали
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             Console.Write($"{matr[i, j]} ");
//         }
//         Console.WriteLine();
//     }
// }
// void FillArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             matr[i, j] = new Random().Next(1, 10);//[1; 10)
//         }
//     }
// }
// int[,] matrix = new int[3, 4];
// PrintArray(matrix);
// FillArray(matrix);
// Console.WriteLine();
// PrintArray(matrix);

// ---------------ЗАКРАС КАРТИНКИ-------

// int[,] pic = new int[,]
// {
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
// {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
// {0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
// {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// };
// void PrintImage(int[,] image) // Делаем + вместо 1 и пробел вместо 0, чтоб получить картинку
// {
//     for (int i = 0; i < image.GetLength(0); i++)
//     {
//         for (int j = 0; j < image.GetLength(1); j++)
//         {
//             if (image[i, j] == 0) Console.Write($" ");
//             else Console.Write($"+");
//         }
//         Console.WriteLine();
//     }
// }
// PrintImage(pic); //это вывод к выше указанному просто картинка не закрашенная

//Дальше предлагаю описать метод, который будет закрашивать картинку. 
// По аналогии назовём его FillImage. А в качестве аргумента я укажу позицию строки и 
// пикселя, с которого мы должны будем начать закраску. Дальше я проверяю условие: 
// если текущий пиксель (pic) с указанной позицией (row,col) равен нулю (то есть не закрашен), я буду его красить единичкой. А дальше вызову FillImage. И
// здесь мы определяем правило — что за чем идёт. 
// Сначала поднимаемся на строчку выше (row-1, col),потом идём влево (row, col-1),
//  потом вниз (row+1, col), потом вправо (row, col+1).

// void FillImage(int row, int col)
// {
//  if (pic[row, col] == 0)
//  {
//  pic[row, col] = 1;
//  FillImage(row - 1, col);
//  FillImage(row, col - 1);
//  FillImage(row + 1, col);
//  FillImage(row, col + 1);
//  }
// }
// PrintImage(pic); // не закрашенная картинка, потом ввод закрашенной
// FillImage(13, 13);
// PrintImage(pic);

// ------------Рекурсия--------ВЫчисление факториала----------
// Программисты выяснили, что если мы считаем 5 * на произведение чисел от 1 до 4, по определению
// факториала, это 4!. Таким образом, 5! мы можем представить как 5 * 4!. 4! — это 4 * 3! и так далее.
// Таким образом, мы смогли задать функцию через саму себя. Попробуем написать это кодом.


// int Factorial(int n)
// {
//     // 1! = 1
//     // 0! = 1
//     if (n == 1) return 1;
//     else return n * Factorial(n - 1);
// }
// Console.WriteLine(Factorial(3)); // 1 * 2 * 3 = 6
// То есть число 17! попросту не вмещается в тип данных integer, поэтому появляется первая ваша задача,
// связанная с переполнением. Как её решать? Разными способами. Есть тип данных, который такие числа
// ещё способен переваривать, — double. Давайте integer заменим на double для возвращаемого
// результата. Потому что аргументом мы здесь передаём только число до 40. 
// Видим нормальные значения. E + 29 означает, что получившееся число нужно умножить на 10
// 29. Этодостаточно большие числа. Но тип double позволяет их хранить.

// double Factorial(int n)
// {
//     // 1! = 1
//     // 0! = 1
//     if (n == 1) return 1;
//     else return n * Factorial(n - 1);
// }
// for (int i = 1; i < 40; i++)
// {
//     Console.WriteLine($"{i}! = {Factorial(i)}");
// }

// -------------ЧИСЛА ФИНАБОЧИ-------
// Чи́сла Фибона́ччи — элементы числовой последовательности
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, … (последовательность A000045 в OEIS),
// в которой первые два числа равны 0 и 1, а каждое последующее число равно сумме двух 
// предыдущих чисел

// f(1) = 1
// f(2) = 1
// f(n) = f(n-1) + f(n-2)
int Fibonacci(int n)   //double Fibonacci(int n) замени на дабл, если числа большие, до 40 еще нормально,. потом медленно

{
    if (n == 1 || n == 2) return 1;
    else return Fibonacci(n - 1) + Fibonacci(n - 2);
}
for (int i = 1; i < 10; i++)
{
    Console.WriteLine(Fibonacci(i));
}
